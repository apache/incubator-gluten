== Physical Plan ==
VeloxColumnarToRowExec (23)
+- ^ SortExecTransformer (21)
   +- ^ InputIteratorTransformer (20)
      +- ColumnarExchange (19)
         +- ^ ProjectExecTransformer (17)
            +- ^ GlutenBroadcastHashJoinExecTransformer Inner (16)
               :- ^ InputIteratorTransformer (5)
               :  +- ColumnarBroadcastExchange (4)
               :     +- ^ FilterExecTransformer (2)
               :        +- ^ Scan parquet spark_catalog.default.supplier (1)
               +- ^ FilterExecTransformer (15)
                  +- ^ RegularHashAggregateExecTransformer (14)
                     +- ^ InputIteratorTransformer (13)
                        +- ColumnarExchange (12)
                           +- ^ ProjectExecTransformer (10)
                              +- ^ FlushableHashAggregateExecTransformer (9)
                                 +- ^ ProjectExecTransformer (8)
                                    +- ^ FilterExecTransformer (7)
                                       +- ^ Scan parquet spark_catalog.default.lineitem (6)


(1) Scan parquet spark_catalog.default.supplier
Output [4]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-1.0/supplier]
PushedFilters: [IsNotNull(s_suppkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_phone:string>

(2) FilterExecTransformer
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X]
Arguments: isnotnull(s_suppkey#X)

(3) WholeStageCodegenTransformer (X)
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X]
Arguments: false
Native Plan:
-- TableScan

(4) ColumnarBroadcastExchange
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X]
Arguments: HashedRelationBroadcastMode(List(input[0, bigint, false]),false), [plan_id=X]

(5) InputIteratorTransformer
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X]

(6) Scan parquet spark_catalog.default.lineitem
Output [4]: [l_suppkey#X, l_extendedprice#X, l_discount#X, l_shipdate#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-1.0/lineitem]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01), IsNotNull(l_suppkey)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(7) FilterExecTransformer
Input [4]: [l_suppkey#X, l_extendedprice#X, l_discount#X, l_shipdate#X]
Arguments: (((isnotnull(l_shipdate#X) AND (l_shipdate#X >= 1996-01-01)) AND (l_shipdate#X < 1996-04-01)) AND isnotnull(l_suppkey#X))

(8) ProjectExecTransformer
Input [4]: [l_suppkey#X, l_extendedprice#X, l_discount#X, l_shipdate#X]
Arguments: [l_suppkey#X, l_extendedprice#X, l_discount#X]

(9) FlushableHashAggregateExecTransformer
Input [3]: [l_suppkey#X, l_extendedprice#X, l_discount#X]
Keys [1]: [l_suppkey#X]
Functions [1]: [partial_sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [2]: [sum#X, isEmpty#X]
Results [3]: [l_suppkey#X, sum#X, isEmpty#X]

(10) ProjectExecTransformer
Input [3]: [l_suppkey#X, sum#X, isEmpty#X]
Arguments: [hash(l_suppkey#X, 42) AS hash_partition_key#X, l_suppkey#X, sum#X, isEmpty#X]

(11) WholeStageCodegenTransformer (X)
Input [4]: [hash_partition_key#X, l_suppkey#X, sum#X, isEmpty#X]
Arguments: false
Native Plan:
-- Project
  -- Project
    -- Aggregation
      -- Project
        -- Project
          -- TableScan

(12) ColumnarExchange
Input [4]: [hash_partition_key#X, l_suppkey#X, sum#X, isEmpty#X]
Arguments: hashpartitioning(l_suppkey#X, 100), ENSURE_REQUIREMENTS, [l_suppkey#X, sum#X, isEmpty#X], [plan_id=X], [id=#X]

(13) InputIteratorTransformer
Input [3]: [l_suppkey#X, sum#X, isEmpty#X]

(14) RegularHashAggregateExecTransformer
Input [3]: [l_suppkey#X, sum#X, isEmpty#X]
Keys [1]: [l_suppkey#X]
Functions [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X]
Results [2]: [l_suppkey#X AS supplier_no#X, sum((l_extendedprice#X * (1 - l_discount#X)))#X AS total_revenue#X]

(15) FilterExecTransformer
Input [2]: [supplier_no#X, total_revenue#X]
Arguments: (isnotnull(total_revenue#X) AND (total_revenue#X = Subquery scalar-subquery#X, [id=#X]))

(16) GlutenBroadcastHashJoinExecTransformer
Left keys [1]: [s_suppkey#X]
Right keys [1]: [supplier_no#X]
Join type: Inner
Join condition: None

(17) ProjectExecTransformer
Input [6]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, supplier_no#X, total_revenue#X]
Arguments: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]

(18) WholeStageCodegenTransformer (X)
Input [5]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]
Arguments: false
Native Plan:
-- Project
  -- Project
    -- HashJoin
      -- Filter
        -- Project
          -- Aggregation
            -- Project
              -- ValueStream
      -- ValueStream

(19) ColumnarExchange
Input [5]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]
Arguments: rangepartitioning(s_suppkey#X ASC NULLS FIRST, 100), ENSURE_REQUIREMENTS, [plan_id=X], [id=#X]

(20) InputIteratorTransformer
Input [5]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]

(21) SortExecTransformer
Input [5]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]
Arguments: [s_suppkey#X ASC NULLS FIRST], true, 0

(22) WholeStageCodegenTransformer (X)
Input [5]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]
Arguments: false
Native Plan:
-- OrderBy
  -- ValueStream

(23) VeloxColumnarToRowExec
Input [5]: [s_suppkey#X, s_name#X, s_address#X, s_phone#X, total_revenue#X]

===== Subqueries =====

Subquery:1 Hosting operator id = 15 Hosting Expression = Subquery scalar-subquery#X, [id=#X]
VeloxColumnarToRowExec (39)
+- ^ RegularHashAggregateExecTransformer (37)
   +- ^ InputIteratorTransformer (36)
      +- ColumnarExchange (35)
         +- ^ FlushableHashAggregateExecTransformer (33)
            +- ^ RegularHashAggregateExecTransformer (32)
               +- ^ InputIteratorTransformer (31)
                  +- ColumnarExchange (30)
                     +- ^ ProjectExecTransformer (28)
                        +- ^ FlushableHashAggregateExecTransformer (27)
                           +- ^ ProjectExecTransformer (26)
                              +- ^ FilterExecTransformer (25)
                                 +- ^ Scan parquet spark_catalog.default.lineitem (24)


(24) Scan parquet spark_catalog.default.lineitem
Output [4]: [l_suppkey#X, l_extendedprice#X, l_discount#X, l_shipdate#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-1.0/lineitem]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(25) FilterExecTransformer
Input [4]: [l_suppkey#X, l_extendedprice#X, l_discount#X, l_shipdate#X]
Arguments: ((isnotnull(l_shipdate#X) AND (l_shipdate#X >= 1996-01-01)) AND (l_shipdate#X < 1996-04-01))

(26) ProjectExecTransformer
Input [4]: [l_suppkey#X, l_extendedprice#X, l_discount#X, l_shipdate#X]
Arguments: [l_suppkey#X, l_extendedprice#X, l_discount#X]

(27) FlushableHashAggregateExecTransformer
Input [3]: [l_suppkey#X, l_extendedprice#X, l_discount#X]
Keys [1]: [l_suppkey#X]
Functions [1]: [partial_sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [2]: [sum#X, isEmpty#X]
Results [3]: [l_suppkey#X, sum#X, isEmpty#X]

(28) ProjectExecTransformer
Input [3]: [l_suppkey#X, sum#X, isEmpty#X]
Arguments: [hash(l_suppkey#X, 42) AS hash_partition_key#X, l_suppkey#X, sum#X, isEmpty#X]

(29) WholeStageCodegenTransformer (X)
Input [4]: [hash_partition_key#X, l_suppkey#X, sum#X, isEmpty#X]
Arguments: false
Native Plan:
-- Project[expressions: (n5_3:INTEGER, hash_with_seed(42,"n4_2")), (n5_4:BIGINT, "n4_2"), (n5_5:DECIMAL(36, 4), "n4_3"), (n5_6:BOOLEAN, "n4_4")] -> n5_3:INTEGER, n5_4:BIGINT, n5_5:DECIMAL(36, 4), n5_6:BOOLEAN
  -- Project[expressions: (n4_2:BIGINT, "n2_3"), (n4_3:DECIMAL(36, 4), "n3_1"["col_0"]), (n4_4:BOOLEAN, "n3_1"["col_1"])] -> n4_2:BIGINT, n4_3:DECIMAL(36, 4), n4_4:BOOLEAN
    -- Aggregation[PARTIAL [n2_3] n3_1 := sum_partial("n2_4")] -> n2_3:BIGINT, n3_1:ROW<col_0:DECIMAL(36, 4),col_1:BOOLEAN>
      -- Project[expressions: (n2_3:BIGINT, "n1_4"), (n2_4:DECIMAL(26, 4), multiply("n1_5",subtract(1,"n1_6")))] -> n2_3:BIGINT, n2_4:DECIMAL(26, 4)
        -- Project[expressions: (n1_4:BIGINT, "n0_0"), (n1_5:DECIMAL(12, 2), "n0_1"), (n1_6:DECIMAL(12, 2), "n0_2")] -> n1_4:BIGINT, n1_5:DECIMAL(12, 2), n1_6:DECIMAL(12, 2)
          -- TableScan[table: hive_table, range filters: [(l_shipdate, BigintRange: [9496, 9586] no nulls)]] -> n0_0:BIGINT, n0_1:DECIMAL(12, 2), n0_2:DECIMAL(12, 2), n0_3:DATE

(30) ColumnarExchange
Input [4]: [hash_partition_key#X, l_suppkey#X, sum#X, isEmpty#X]
Arguments: hashpartitioning(l_suppkey#X, 100), ENSURE_REQUIREMENTS, [l_suppkey#X, sum#X, isEmpty#X], [plan_id=X], [id=#X]

(31) InputIteratorTransformer
Input [3]: [l_suppkey#X, sum#X, isEmpty#X]

(32) RegularHashAggregateExecTransformer
Input [3]: [l_suppkey#X, sum#X, isEmpty#X]
Keys [1]: [l_suppkey#X]
Functions [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X]
Results [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X AS total_revenue#X]

(33) FlushableHashAggregateExecTransformer
Input [1]: [total_revenue#X]
Keys: []
Functions [1]: [partial_max(total_revenue#X)]
Aggregate Attributes [1]: [max#X]
Results [1]: [max#X]

(34) WholeStageCodegenTransformer (X)
Input [1]: [max#X]
Arguments: false
Native Plan:
-- Aggregation[PARTIAL n4_0 := max_partial("n3_2")] -> n4_0:DECIMAL(36, 4)
  -- Project[expressions: (n3_2:DECIMAL(36, 4), "n2_1")] -> n3_2:DECIMAL(36, 4)
    -- Aggregation[SINGLE [n1_3] n2_1 := sum_merge_extract("n1_4")] -> n1_3:BIGINT, n2_1:DECIMAL(36, 4)
      -- Project[expressions: (n1_3:BIGINT, "n0_0"), (n1_4:ROW<col_0:DECIMAL(36, 4),col_1:BOOLEAN>, row_constructor("n0_1","n0_2"))] -> n1_3:BIGINT, n1_4:ROW<col_0:DECIMAL(36, 4),col_1:BOOLEAN>
        -- ValueStream[] -> n0_0:BIGINT, n0_1:DECIMAL(36, 4), n0_2:BOOLEAN

(35) ColumnarExchange
Input [1]: [max#X]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=X], [id=#X]

(36) InputIteratorTransformer
Input [1]: [max#X]

(37) RegularHashAggregateExecTransformer
Input [1]: [max#X]
Keys: []
Functions [1]: [max(total_revenue#X)]
Aggregate Attributes [1]: [max(total_revenue#X)#X]
Results [1]: [max(total_revenue#X)#X AS max(total_revenue)#X]

(38) WholeStageCodegenTransformer (X)
Input [1]: [max(total_revenue)#X]
Arguments: false
Native Plan:
-- Project[expressions: (n2_1:DECIMAL(36, 4), "n1_0")] -> n2_1:DECIMAL(36, 4)
  -- Aggregation[SINGLE n1_0 := max_merge_extract("n0_0")] -> n1_0:DECIMAL(36, 4)
    -- ValueStream[] -> n0_0:DECIMAL(36, 4)

(39) VeloxColumnarToRowExec
Input [1]: [max(total_revenue)#X]


