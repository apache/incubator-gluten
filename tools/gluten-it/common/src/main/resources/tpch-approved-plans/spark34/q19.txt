== Physical Plan ==
AdaptiveSparkPlan (31)
+- == Final Plan ==
   VeloxColumnarToRowExec (19)
   +- ^ RegularHashAggregateExecTransformer (17)
      +- ^ InputIteratorTransformer (16)
         +- ShuffleQueryStage (15), Statistics(X)
            +- ColumnarExchange (14)
               +- ^ FlushableHashAggregateExecTransformer (12)
                  +- ^ ProjectExecTransformer (11)
                     +- ^ GlutenBroadcastHashJoinExecTransformer Inner (10)
                        :- ^ ProjectExecTransformer (3)
                        :  +- ^ FilterExecTransformer (2)
                        :     +- ^ Scan parquet spark_catalog.default.lineitem (1)
                        +- ^ InputIteratorTransformer (9)
                           +- BroadcastQueryStage (8), Statistics(X)
                              +- ColumnarBroadcastExchange (7)
                                 +- ^ FilterExecTransformer (5)
                                    +- ^ Scan parquet spark_catalog.default.part (4)
+- == Initial Plan ==
   HashAggregate (30)
   +- Exchange (29)
      +- HashAggregate (28)
         +- Project (27)
            +- BroadcastHashJoin Inner BuildRight (26)
               :- Project (22)
               :  +- Filter (21)
               :     +- Scan parquet spark_catalog.default.lineitem (20)
               +- BroadcastExchange (25)
                  +- Filter (24)
                     +- Scan parquet spark_catalog.default.part (23)


(1) Scan parquet spark_catalog.default.lineitem
Output [6]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, l_shipinstruct#X, l_shipmode#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-0.1/lineitem]
PushedFilters: [IsNotNull(l_shipinstruct), In(l_shipmode, [AIR,AIR REG]), EqualTo(l_shipinstruct,DELIVER IN PERSON), IsNotNull(l_partkey), Or(Or(And(GreaterThanOrEqual(l_quantity,1.00),LessThanOrEqual(l_quantity,11.00)),And(GreaterThanOrEqual(l_quantity,10.00),LessThanOrEqual(l_quantity,20.00))),And(GreaterThanOrEqual(l_quantity,20.00),LessThanOrEqual(l_quantity,30.00)))]
ReadSchema: struct<l_partkey:bigint,l_quantity:decimal(12,2),l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipinstruct:string,l_shipmode:string>

(2) FilterExecTransformer
Input [6]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, l_shipinstruct#X, l_shipmode#X]
Arguments: ((((isnotnull(l_shipinstruct#X) AND l_shipmode#X IN (AIR,AIR REG)) AND (l_shipinstruct#X = DELIVER IN PERSON)) AND isnotnull(l_partkey#X)) AND ((((l_quantity#X >= 1.00) AND (l_quantity#X <= 11.00)) OR ((l_quantity#X >= 10.00) AND (l_quantity#X <= 20.00))) OR ((l_quantity#X >= 20.00) AND (l_quantity#X <= 30.00))))

(3) ProjectExecTransformer
Input [6]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, l_shipinstruct#X, l_shipmode#X]
Arguments: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X]

(4) Scan parquet spark_catalog.default.part
Output [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-0.1/part]
PushedFilters: [IsNotNull(p_size), GreaterThanOrEqual(p_size,1), IsNotNull(p_partkey), Or(Or(And(And(EqualTo(p_brand,Brand#X),In(p_container, [SM BOX,SM CASE,SM PACK,SM PKG])),LessThanOrEqual(p_size,5)),And(And(EqualTo(p_brand,Brand#X),In(p_container, [MED BAG,MED BOX,MED PACK,MED PKG])),LessThanOrEqual(p_size,10))),And(And(EqualTo(p_brand,Brand#X),In(p_container, [LG BOX,LG CASE,LG PACK,LG PKG])),LessThanOrEqual(p_size,15)))]
ReadSchema: struct<p_partkey:bigint,p_size:int,p_container:string,p_brand:string>

(5) FilterExecTransformer
Input [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Arguments: (((isnotnull(p_size#X) AND (p_size#X >= 1)) AND isnotnull(p_partkey#X)) AND (((((p_brand#X = Brand#X) AND p_container#X IN (SM CASE,SM BOX,SM PACK,SM PKG)) AND (p_size#X <= 5)) OR (((p_brand#X = Brand#X) AND p_container#X IN (MED BAG,MED BOX,MED PKG,MED PACK)) AND (p_size#X <= 10))) OR (((p_brand#X = Brand#X) AND p_container#X IN (LG CASE,LG BOX,LG PACK,LG PKG)) AND (p_size#X <= 15))))

(6) WholeStageCodegenTransformer (X)
Input [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Arguments: false
Native Plan:
-- TableScan[table: hive_table, range filters: [(p_partkey, Filter(IsNotNull, deterministic, null not allowed)), (p_size, BigintRange: [1, 2147483647] no nulls)], remaining filter: (or(or(and(and(equalto("p_brand","Brand#X"),in("p_container",4 elements starting at 0 {SM CASE, SM BOX, SM PACK, SM PKG})),lessthanorequal("p_size",5)),and(and(equalto("p_brand","Brand#X"),in("p_container",4 elements starting at 0 {MED BAG, MED BOX, MED PKG, MED PACK})),lessthanorequal("p_size",10))),and(and(equalto("p_brand","Brand#X"),in("p_container",4 elements starting at 0 {LG CASE, LG BOX, LG PACK, LG PKG})),lessthanorequal("p_size",15))))] -> n0_0:BIGINT, n0_1:INTEGER, n0_2:VARCHAR, n0_3:VARCHAR

(7) ColumnarBroadcastExchange
Input [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Arguments: HashedRelationBroadcastMode(List(input[0, bigint, false]),false), [plan_id=X]

(8) BroadcastQueryStage
Output [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Arguments: 0

(9) InputIteratorTransformer
Input [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]

(10) GlutenBroadcastHashJoinExecTransformer
Left keys [1]: [l_partkey#X]
Right keys [1]: [p_partkey#X]
Join type: Inner
Join condition: (((((((p_brand#X = Brand#X) AND p_container#X IN (SM CASE,SM BOX,SM PACK,SM PKG)) AND (l_quantity#X >= 1.00)) AND (l_quantity#X <= 11.00)) AND (p_size#X <= 5)) OR (((((p_brand#X = Brand#X) AND p_container#X IN (MED BAG,MED BOX,MED PKG,MED PACK)) AND (l_quantity#X >= 10.00)) AND (l_quantity#X <= 20.00)) AND (p_size#X <= 10))) OR (((((p_brand#X = Brand#X) AND p_container#X IN (LG CASE,LG BOX,LG PACK,LG PKG)) AND (l_quantity#X >= 20.00)) AND (l_quantity#X <= 30.00)) AND (p_size#X <= 15)))

(11) ProjectExecTransformer
Input [8]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, p_partkey#X, p_size#X, p_container#X, p_brand#X]
Arguments: [l_extendedprice#X, l_discount#X]

(12) FlushableHashAggregateExecTransformer
Input [2]: [l_extendedprice#X, l_discount#X]
Keys: []
Functions [1]: [partial_sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [2]: [sum#X, isEmpty#X]
Results [2]: [sum#X, isEmpty#X]

(13) WholeStageCodegenTransformer (X)
Input [2]: [sum#X, isEmpty#X]
Arguments: false
Native Plan:
-- Project[expressions: (n8_1:DECIMAL(36, 4), "n7_0"["col_0"]), (n8_2:BOOLEAN, "n7_0"["col_1"])] -> n8_1:DECIMAL(36, 4), n8_2:BOOLEAN
  -- Aggregation[PARTIAL n7_0 := sum_partial("n6_2")] -> n7_0:ROW<col_0:DECIMAL(36, 4),col_1:BOOLEAN>
    -- Project[expressions: (n6_2:DECIMAL(26, 4), multiply("n5_8",subtract(1,"n5_9")))] -> n6_2:DECIMAL(26, 4)
      -- Project[expressions: (n5_8:DECIMAL(12, 2), "n4_10"), (n5_9:DECIMAL(12, 2), "n4_11")] -> n5_8:DECIMAL(12, 2), n5_9:DECIMAL(12, 2)
        -- Project[expressions: (n4_8:BIGINT, "n2_6"), (n4_9:DECIMAL(12, 2), "n2_7"), (n4_10:DECIMAL(12, 2), "n2_8"), (n4_11:DECIMAL(12, 2), "n2_9"), (n4_12:BIGINT, "n0_0"), (n4_13:INTEGER, "n0_1"), (n4_14:VARCHAR, "n0_2"), (n4_15:VARCHAR, "n0_3")] -> n4_8:BIGINT, n4_9:DECIMAL(12, 2), n4_10:DECIMAL(12, 2), n4_11:DECIMAL(12, 2), n4_12:BIGINT, n4_13:INTEGER, n4_14:VARCHAR, n4_15:VARCHAR
          -- HashJoin[INNER n2_6=n0_0, filter: or(or(and(and(and(and(equalto("n0_3","Brand#X"),in("n0_2",4 elements starting at 0 {SM CASE, SM BOX, SM PACK, SM PKG})),decimal_greaterthanorequal("n2_7",1.00)),decimal_lessthanorequal("n2_7",11.00)),lessthanorequal("n0_1",5)),and(and(and(and(equalto("n0_3","Brand#X"),in("n0_2",4 elements starting at 0 {MED BAG, MED BOX, MED PKG, MED PACK})),decimal_greaterthanorequal("n2_7",10.00)),decimal_lessthanorequal("n2_7",20.00)),lessthanorequal("n0_1",10))),and(and(and(and(equalto("n0_3","Brand#X"),in("n0_2",4 elements starting at 0 {LG CASE, LG BOX, LG PACK, LG PKG})),decimal_greaterthanorequal("n2_7",20.00)),decimal_lessthanorequal("n2_7",30.00)),lessthanorequal("n0_1",15)))] -> n2_6:BIGINT, n2_7:DECIMAL(12, 2), n2_8:DECIMAL(12, 2), n2_9:DECIMAL(12, 2), n0_0:BIGINT, n0_1:INTEGER, n0_2:VARCHAR, n0_3:VARCHAR
            -- Project[expressions: (n2_6:BIGINT, "n1_0"), (n2_7:DECIMAL(12, 2), "n1_1"), (n2_8:DECIMAL(12, 2), "n1_2"), (n2_9:DECIMAL(12, 2), "n1_3")] -> n2_6:BIGINT, n2_7:DECIMAL(12, 2), n2_8:DECIMAL(12, 2), n2_9:DECIMAL(12, 2)
              -- TableScan[table: hive_table, range filters: [(l_partkey, Filter(IsNotNull, deterministic, null not allowed)), (l_shipinstruct, BytesRange: [DELIVER IN PERSON, DELIVER IN PERSON] no nulls), (l_shipmode, Filter(BytesValues, deterministic, null not allowed))], remaining filter: (or(or(and(decimal_greaterthanorequal("l_quantity",1.00),decimal_lessthanorequal("l_quantity",11.00)),and(decimal_greaterthanorequal("l_quantity",10.00),decimal_lessthanorequal("l_quantity",20.00))),and(decimal_greaterthanorequal("l_quantity",20.00),decimal_lessthanorequal("l_quantity",30.00))))] -> n1_0:BIGINT, n1_1:DECIMAL(12, 2), n1_2:DECIMAL(12, 2), n1_3:DECIMAL(12, 2), n1_4:VARCHAR, n1_5:VARCHAR
            -- ValueStream[] -> n0_0:BIGINT, n0_1:INTEGER, n0_2:VARCHAR, n0_3:VARCHAR

(14) ColumnarExchange
Input [2]: [sum#X, isEmpty#X]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=X], [id=#X]

(15) ShuffleQueryStage
Output [2]: [sum#X, isEmpty#X]
Arguments: 1

(16) InputIteratorTransformer
Input [2]: [sum#X, isEmpty#X]

(17) RegularHashAggregateExecTransformer
Input [2]: [sum#X, isEmpty#X]
Keys: []
Functions [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X]
Results [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X AS revenue#X]

(18) WholeStageCodegenTransformer (X)
Input [1]: [revenue#X]
Arguments: false
Native Plan:
-- Project[expressions: (n3_1:DECIMAL(36, 4), "n2_0")] -> n3_1:DECIMAL(36, 4)
  -- Aggregation[SINGLE n2_0 := sum_merge_extract("n1_2")] -> n2_0:DECIMAL(36, 4)
    -- Project[expressions: (n1_2:ROW<col_0:DECIMAL(36, 4),col_1:BOOLEAN>, row_constructor("n0_0","n0_1"))] -> n1_2:ROW<col_0:DECIMAL(36, 4),col_1:BOOLEAN>
      -- ValueStream[] -> n0_0:DECIMAL(36, 4), n0_1:BOOLEAN

(19) VeloxColumnarToRowExec
Input [1]: [revenue#X]

(20) Scan parquet spark_catalog.default.lineitem
Output [6]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, l_shipinstruct#X, l_shipmode#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-0.1/lineitem]
PushedFilters: [IsNotNull(l_shipinstruct), In(l_shipmode, [AIR,AIR REG]), EqualTo(l_shipinstruct,DELIVER IN PERSON), IsNotNull(l_partkey), Or(Or(And(GreaterThanOrEqual(l_quantity,1.00),LessThanOrEqual(l_quantity,11.00)),And(GreaterThanOrEqual(l_quantity,10.00),LessThanOrEqual(l_quantity,20.00))),And(GreaterThanOrEqual(l_quantity,20.00),LessThanOrEqual(l_quantity,30.00)))]
ReadSchema: struct<l_partkey:bigint,l_quantity:decimal(12,2),l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipinstruct:string,l_shipmode:string>

(21) Filter
Input [6]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, l_shipinstruct#X, l_shipmode#X]
Condition : ((((isnotnull(l_shipinstruct#X) AND l_shipmode#X IN (AIR,AIR REG)) AND (l_shipinstruct#X = DELIVER IN PERSON)) AND isnotnull(l_partkey#X)) AND ((((l_quantity#X >= 1.00) AND (l_quantity#X <= 11.00)) OR ((l_quantity#X >= 10.00) AND (l_quantity#X <= 20.00))) OR ((l_quantity#X >= 20.00) AND (l_quantity#X <= 30.00))))

(22) Project
Output [4]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X]
Input [6]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, l_shipinstruct#X, l_shipmode#X]

(23) Scan parquet spark_catalog.default.part
Output [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Batched: true
Location: InMemoryFileIndex [file:/tmp/tpch-generated-0.1/part]
PushedFilters: [IsNotNull(p_size), GreaterThanOrEqual(p_size,1), IsNotNull(p_partkey), Or(Or(And(And(EqualTo(p_brand,Brand#X),In(p_container, [SM BOX,SM CASE,SM PACK,SM PKG])),LessThanOrEqual(p_size,5)),And(And(EqualTo(p_brand,Brand#X),In(p_container, [MED BAG,MED BOX,MED PACK,MED PKG])),LessThanOrEqual(p_size,10))),And(And(EqualTo(p_brand,Brand#X),In(p_container, [LG BOX,LG CASE,LG PACK,LG PKG])),LessThanOrEqual(p_size,15)))]
ReadSchema: struct<p_partkey:bigint,p_size:int,p_container:string,p_brand:string>

(24) Filter
Input [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Condition : (((isnotnull(p_size#X) AND (p_size#X >= 1)) AND isnotnull(p_partkey#X)) AND (((((p_brand#X = Brand#X) AND p_container#X IN (SM CASE,SM BOX,SM PACK,SM PKG)) AND (p_size#X <= 5)) OR (((p_brand#X = Brand#X) AND p_container#X IN (MED BAG,MED BOX,MED PKG,MED PACK)) AND (p_size#X <= 10))) OR (((p_brand#X = Brand#X) AND p_container#X IN (LG CASE,LG BOX,LG PACK,LG PKG)) AND (p_size#X <= 15))))

(25) BroadcastExchange
Input [4]: [p_partkey#X, p_size#X, p_container#X, p_brand#X]
Arguments: HashedRelationBroadcastMode(List(input[0, bigint, false]),false), [plan_id=X]

(26) BroadcastHashJoin
Left keys [1]: [l_partkey#X]
Right keys [1]: [p_partkey#X]
Join type: Inner
Join condition: (((((((p_brand#X = Brand#X) AND p_container#X IN (SM CASE,SM BOX,SM PACK,SM PKG)) AND (l_quantity#X >= 1.00)) AND (l_quantity#X <= 11.00)) AND (p_size#X <= 5)) OR (((((p_brand#X = Brand#X) AND p_container#X IN (MED BAG,MED BOX,MED PKG,MED PACK)) AND (l_quantity#X >= 10.00)) AND (l_quantity#X <= 20.00)) AND (p_size#X <= 10))) OR (((((p_brand#X = Brand#X) AND p_container#X IN (LG CASE,LG BOX,LG PACK,LG PKG)) AND (l_quantity#X >= 20.00)) AND (l_quantity#X <= 30.00)) AND (p_size#X <= 15)))

(27) Project
Output [2]: [l_extendedprice#X, l_discount#X]
Input [8]: [l_partkey#X, l_quantity#X, l_extendedprice#X, l_discount#X, p_partkey#X, p_size#X, p_container#X, p_brand#X]

(28) HashAggregate
Input [2]: [l_extendedprice#X, l_discount#X]
Keys: []
Functions [1]: [partial_sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [2]: [sum#X, isEmpty#X]
Results [2]: [sum#X, isEmpty#X]

(29) Exchange
Input [2]: [sum#X, isEmpty#X]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=X]

(30) HashAggregate
Input [2]: [sum#X, isEmpty#X]
Keys: []
Functions [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))]
Aggregate Attributes [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X]
Results [1]: [sum((l_extendedprice#X * (1 - l_discount#X)))#X AS revenue#X]

(31) AdaptiveSparkPlan
Output [1]: [revenue#X]
Arguments: isFinalPlan=true
