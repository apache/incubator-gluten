== Physical Plan ==
AdaptiveSparkPlan (60)
+- == Final Plan ==
   VeloxColumnarToRowExec (31)
   +- ^ SortExecTransformer (29)
      +- ^ ProjectExecTransformer (28)
         +- ^ ShuffledHashJoinExecTransformer Inner (27)
            :- ^ ProjectExecTransformer (23)
            :  +- ^ ShuffledHashJoinExecTransformer LeftSemi (22)
            :     :- ^ FilterExecTransformer (2)
            :     :  +- ^ BatchScanExecTransformer (1)
            :     +- ^ ProjectExecTransformer (21)
            :        +- ^ ShuffledHashJoinExecTransformer Inner (20)
            :           :- ^ ShuffledHashJoinExecTransformer LeftSemi (8)
            :           :  :- ^ FilterExecTransformer (4)
            :           :  :  +- ^ BatchScanExecTransformer (3)
            :           :  +- ^ ProjectExecTransformer (7)
            :           :     +- ^ FilterExecTransformer (6)
            :           :        +- ^ BatchScanExecTransformer (5)
            :           +- ^ FilterExecTransformer (19)
            :              +- ^ ProjectExecTransformer (18)
            :                 +- ^ RegularHashAggregateExecTransformer (17)
            :                    +- ^ RegularHashAggregateExecTransformer (16)
            :                       +- ^ ShuffledHashJoinExecTransformer LeftSemi (15)
            :                          :- ^ ProjectExecTransformer (11)
            :                          :  +- ^ FilterExecTransformer (10)
            :                          :     +- ^ BatchScanExecTransformer (9)
            :                          +- ^ ProjectExecTransformer (14)
            :                             +- ^ FilterExecTransformer (13)
            :                                +- ^ BatchScanExecTransformer (12)
            +- ^ ProjectExecTransformer (26)
               +- ^ FilterExecTransformer (25)
                  +- ^ BatchScanExecTransformer (24)
+- == Initial Plan ==
   Sort (59)
   +- Project (58)
      +- ShuffledHashJoin Inner BuildRight (57)
         :- Project (53)
         :  +- ShuffledHashJoin LeftSemi BuildRight (52)
         :     :- Filter (33)
         :     :  +- BatchScan (32)
         :     +- Project (51)
         :        +- ShuffledHashJoin Inner BuildLeft (50)
         :           :- ShuffledHashJoin LeftSemi BuildRight (39)
         :           :  :- Filter (35)
         :           :  :  +- BatchScan (34)
         :           :  +- Project (38)
         :           :     +- Filter (37)
         :           :        +- BatchScan (36)
         :           +- Filter (49)
         :              +- HashAggregate (48)
         :                 +- HashAggregate (47)
         :                    +- ShuffledHashJoin LeftSemi BuildRight (46)
         :                       :- Project (42)
         :                       :  +- Filter (41)
         :                       :     +- BatchScan (40)
         :                       +- Project (45)
         :                          +- Filter (44)
         :                             +- BatchScan (43)
         +- Project (56)
            +- Filter (55)
               +- BatchScan (54)


(1) BatchScanExecTransformer
Output [4]: [s_suppkey#X, s_name#X, s_address#X, s_nationkey#X]
DataFilters: [isnotnull(s_nationkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(s_nationkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_nationkey:bigint>

(2) FilterExecTransformer
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_nationkey#X]
Arguments: isnotnull(s_nationkey#X)

(3) BatchScanExecTransformer
Output [3]: [ps_partkey#X, ps_suppkey#X, ps_availqty#X]
DataFilters: [isnotnull(ps_availqty#X), isnotnull(ps_partkey#X), isnotnull(ps_suppkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(ps_availqty), IsNotNull(ps_partkey), IsNotNull(ps_suppkey)]
ReadSchema: struct<ps_partkey:bigint,ps_suppkey:bigint,ps_availqty:int>

(4) FilterExecTransformer
Input [3]: [ps_partkey#X, ps_suppkey#X, ps_availqty#X]
Arguments: ((isnotnull(ps_availqty#X) AND isnotnull(ps_partkey#X)) AND isnotnull(ps_suppkey#X))

(5) BatchScanExecTransformer
Output [2]: [p_partkey#X, p_name#X]
DataFilters: [isnotnull(p_name#X), StartsWith(p_name#X, forest)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(p_name), StringStartsWith(p_name,forest)]
ReadSchema: struct<p_partkey:bigint,p_name:string>

(6) FilterExecTransformer
Input [2]: [p_partkey#X, p_name#X]
Arguments: (isnotnull(p_name#X) AND StartsWith(p_name#X, forest))

(7) ProjectExecTransformer
Output [1]: [p_partkey#X]
Input [2]: [p_partkey#X, p_name#X]

(8) ShuffledHashJoinExecTransformer
Left keys [1]: [ps_partkey#X]
Right keys [1]: [p_partkey#X]
Join condition: None

(9) BatchScanExecTransformer
Output [4]: [l_partkey#X, l_suppkey#X, l_quantity#X, l_shipdate#X]
DataFilters: [isnotnull(l_shipdate#X), (l_shipdate#X >= 1994-01-01), (l_shipdate#X < 1995-01-01)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1994-01-01), LessThan(l_shipdate,1995-01-01)]
ReadSchema: struct<l_partkey:bigint,l_suppkey:bigint,l_quantity:decimal(12,2),l_shipdate:date>

(10) FilterExecTransformer
Input [4]: [l_partkey#X, l_suppkey#X, l_quantity#X, l_shipdate#X]
Arguments: ((((isnotnull(l_shipdate#X) AND (l_shipdate#X >= 1994-01-01)) AND (l_shipdate#X < 1995-01-01)) AND isnotnull(l_partkey#X)) AND isnotnull(l_suppkey#X))

(11) ProjectExecTransformer
Output [3]: [l_partkey#X, l_suppkey#X, l_quantity#X]
Input [4]: [l_partkey#X, l_suppkey#X, l_quantity#X, l_shipdate#X]

(12) BatchScanExecTransformer
Output [2]: [p_partkey#X, p_name#X]
DataFilters: [isnotnull(p_name#X), StartsWith(p_name#X, forest)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(p_name), StringStartsWith(p_name,forest)]
ReadSchema: struct<p_partkey:bigint,p_name:string>

(13) FilterExecTransformer
Input [2]: [p_partkey#X, p_name#X]
Arguments: (isnotnull(p_name#X) AND StartsWith(p_name#X, forest))

(14) ProjectExecTransformer
Output [1]: [p_partkey#X]
Input [2]: [p_partkey#X, p_name#X]

(15) ShuffledHashJoinExecTransformer
Left keys [1]: [l_partkey#X]
Right keys [1]: [p_partkey#X]
Join condition: None

(16) RegularHashAggregateExecTransformer
Input [3]: [l_partkey#X, l_suppkey#X, l_quantity#X]
Keys [2]: [l_partkey#X, l_suppkey#X]
Functions [1]: [partial_sum(l_quantity#X)]
Aggregate Attributes [2]: [sum#X, isEmpty#X]
Results [4]: [l_partkey#X, l_suppkey#X, sum#X, isEmpty#X]

(17) RegularHashAggregateExecTransformer
Input [4]: [l_partkey#X, l_suppkey#X, sum#X, isEmpty#X]
Keys [2]: [l_partkey#X, l_suppkey#X]
Functions [1]: [sum(l_quantity#X)]
Aggregate Attributes [1]: [sum(l_quantity#X)#X]
Results [3]: [l_partkey#X, l_suppkey#X, sum(l_quantity#X)#X]

(18) ProjectExecTransformer
Output [3]: [CheckOverflow((0.50 * promote_precision(sum(l_quantity#X)#X)), DecimalType(24,3), true) AS (0.5 * sum(l_quantity))#X, l_partkey#X, l_suppkey#X]
Input [3]: [l_partkey#X, l_suppkey#X, sum(l_quantity#X)#X]

(19) FilterExecTransformer
Input [3]: [(0.5 * sum(l_quantity))#X, l_partkey#X, l_suppkey#X]
Arguments: isnotnull((0.5 * sum(l_quantity))#X)

(20) ShuffledHashJoinExecTransformer
Left keys [2]: [ps_partkey#X, ps_suppkey#X]
Right keys [2]: [l_partkey#X, l_suppkey#X]
Join condition: (cast(cast(ps_availqty#X as decimal(10,0)) as decimal(24,3)) > (0.5 * sum(l_quantity))#X)

(21) ProjectExecTransformer
Output [1]: [ps_suppkey#X]
Input [6]: [ps_partkey#X, ps_suppkey#X, ps_availqty#X, (0.5 * sum(l_quantity))#X, l_partkey#X, l_suppkey#X]

(22) ShuffledHashJoinExecTransformer
Left keys [1]: [s_suppkey#X]
Right keys [1]: [ps_suppkey#X]
Join condition: None

(23) ProjectExecTransformer
Output [3]: [s_name#X, s_address#X, s_nationkey#X]
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_nationkey#X]

(24) BatchScanExecTransformer
Output [2]: [n_nationkey#X, n_name#X]
DataFilters: [isnotnull(n_name#X), (n_name#X = CANADA), isnotnull(n_nationkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(n_name), EqualTo(n_name,CANADA), IsNotNull(n_nationkey)]
ReadSchema: struct<n_nationkey:bigint,n_name:string>

(25) FilterExecTransformer
Input [2]: [n_nationkey#X, n_name#X]
Arguments: ((isnotnull(n_name#X) AND (n_name#X = CANADA)) AND isnotnull(n_nationkey#X))

(26) ProjectExecTransformer
Output [1]: [n_nationkey#X]
Input [2]: [n_nationkey#X, n_name#X]

(27) ShuffledHashJoinExecTransformer
Left keys [1]: [s_nationkey#X]
Right keys [1]: [n_nationkey#X]
Join condition: None

(28) ProjectExecTransformer
Output [2]: [s_name#X, s_address#X]
Input [4]: [s_name#X, s_address#X, s_nationkey#X, n_nationkey#X]

(29) SortExecTransformer
Input [2]: [s_name#X, s_address#X]
Arguments: [s_name#X ASC NULLS FIRST], true, 0

(30) WholeStageCodegenTransformer (X)
Input [2]: [s_name#X, s_address#X]
Arguments: false

(31) VeloxColumnarToRowExec
Input [2]: [s_name#X, s_address#X]

(32) BatchScan
Output [4]: [s_suppkey#X, s_name#X, s_address#X, s_nationkey#X]
DataFilters: [isnotnull(s_nationkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(s_nationkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_nationkey:bigint>

(33) Filter
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_nationkey#X]
Condition : isnotnull(s_nationkey#X)

(34) BatchScan
Output [3]: [ps_partkey#X, ps_suppkey#X, ps_availqty#X]
DataFilters: [isnotnull(ps_availqty#X), isnotnull(ps_partkey#X), isnotnull(ps_suppkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(ps_availqty), IsNotNull(ps_partkey), IsNotNull(ps_suppkey)]
ReadSchema: struct<ps_partkey:bigint,ps_suppkey:bigint,ps_availqty:int>

(35) Filter
Input [3]: [ps_partkey#X, ps_suppkey#X, ps_availqty#X]
Condition : ((isnotnull(ps_availqty#X) AND isnotnull(ps_partkey#X)) AND isnotnull(ps_suppkey#X))

(36) BatchScan
Output [2]: [p_partkey#X, p_name#X]
DataFilters: [isnotnull(p_name#X), StartsWith(p_name#X, forest)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(p_name), StringStartsWith(p_name,forest)]
ReadSchema: struct<p_partkey:bigint,p_name:string>

(37) Filter
Input [2]: [p_partkey#X, p_name#X]
Condition : (isnotnull(p_name#X) AND StartsWith(p_name#X, forest))

(38) Project
Output [1]: [p_partkey#X]
Input [2]: [p_partkey#X, p_name#X]

(39) ShuffledHashJoin
Left keys [1]: [ps_partkey#X]
Right keys [1]: [p_partkey#X]
Join condition: None

(40) BatchScan
Output [4]: [l_partkey#X, l_suppkey#X, l_quantity#X, l_shipdate#X]
DataFilters: [isnotnull(l_shipdate#X), (l_shipdate#X >= 1994-01-01), (l_shipdate#X < 1995-01-01)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1994-01-01), LessThan(l_shipdate,1995-01-01)]
ReadSchema: struct<l_partkey:bigint,l_suppkey:bigint,l_quantity:decimal(12,2),l_shipdate:date>

(41) Filter
Input [4]: [l_partkey#X, l_suppkey#X, l_quantity#X, l_shipdate#X]
Condition : ((((isnotnull(l_shipdate#X) AND (l_shipdate#X >= 1994-01-01)) AND (l_shipdate#X < 1995-01-01)) AND isnotnull(l_partkey#X)) AND isnotnull(l_suppkey#X))

(42) Project
Output [3]: [l_partkey#X, l_suppkey#X, l_quantity#X]
Input [4]: [l_partkey#X, l_suppkey#X, l_quantity#X, l_shipdate#X]

(43) BatchScan
Output [2]: [p_partkey#X, p_name#X]
DataFilters: [isnotnull(p_name#X), StartsWith(p_name#X, forest)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(p_name), StringStartsWith(p_name,forest)]
ReadSchema: struct<p_partkey:bigint,p_name:string>

(44) Filter
Input [2]: [p_partkey#X, p_name#X]
Condition : (isnotnull(p_name#X) AND StartsWith(p_name#X, forest))

(45) Project
Output [1]: [p_partkey#X]
Input [2]: [p_partkey#X, p_name#X]

(46) ShuffledHashJoin
Left keys [1]: [l_partkey#X]
Right keys [1]: [p_partkey#X]
Join condition: None

(47) HashAggregate
Input [3]: [l_partkey#X, l_suppkey#X, l_quantity#X]
Keys [2]: [l_partkey#X, l_suppkey#X]
Functions [1]: [partial_sum(l_quantity#X)]
Aggregate Attributes [2]: [sum#X, isEmpty#X]
Results [4]: [l_partkey#X, l_suppkey#X, sum#X, isEmpty#X]

(48) HashAggregate
Input [4]: [l_partkey#X, l_suppkey#X, sum#X, isEmpty#X]
Keys [2]: [l_partkey#X, l_suppkey#X]
Functions [1]: [sum(l_quantity#X)]
Aggregate Attributes [1]: [sum(l_quantity#X)#X]
Results [3]: [CheckOverflow((0.50 * promote_precision(sum(l_quantity#X)#X)), DecimalType(24,3), true) AS (0.5 * sum(l_quantity))#X, l_partkey#X, l_suppkey#X]

(49) Filter
Input [3]: [(0.5 * sum(l_quantity))#X, l_partkey#X, l_suppkey#X]
Condition : isnotnull((0.5 * sum(l_quantity))#X)

(50) ShuffledHashJoin
Left keys [2]: [ps_partkey#X, ps_suppkey#X]
Right keys [2]: [l_partkey#X, l_suppkey#X]
Join condition: (cast(cast(ps_availqty#X as decimal(10,0)) as decimal(24,3)) > (0.5 * sum(l_quantity))#X)

(51) Project
Output [1]: [ps_suppkey#X]
Input [6]: [ps_partkey#X, ps_suppkey#X, ps_availqty#X, (0.5 * sum(l_quantity))#X, l_partkey#X, l_suppkey#X]

(52) ShuffledHashJoin
Left keys [1]: [s_suppkey#X]
Right keys [1]: [ps_suppkey#X]
Join condition: None

(53) Project
Output [3]: [s_name#X, s_address#X, s_nationkey#X]
Input [4]: [s_suppkey#X, s_name#X, s_address#X, s_nationkey#X]

(54) BatchScan
Output [2]: [n_nationkey#X, n_name#X]
DataFilters: [isnotnull(n_name#X), (n_name#X = CANADA), isnotnull(n_nationkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(n_name), EqualTo(n_name,CANADA), IsNotNull(n_nationkey)]
ReadSchema: struct<n_nationkey:bigint,n_name:string>

(55) Filter
Input [2]: [n_nationkey#X, n_name#X]
Condition : ((isnotnull(n_name#X) AND (n_name#X = CANADA)) AND isnotnull(n_nationkey#X))

(56) Project
Output [1]: [n_nationkey#X]
Input [2]: [n_nationkey#X, n_name#X]

(57) ShuffledHashJoin
Left keys [1]: [s_nationkey#X]
Right keys [1]: [n_nationkey#X]
Join condition: None

(58) Project
Output [2]: [s_name#X, s_address#X]
Input [4]: [s_name#X, s_address#X, s_nationkey#X, n_nationkey#X]

(59) Sort
Input [2]: [s_name#X, s_address#X]
Arguments: [s_name#X ASC NULLS FIRST], true, 0

(60) AdaptiveSparkPlan
Output [2]: [s_name#X, s_address#X]
Arguments: isFinalPlan=true