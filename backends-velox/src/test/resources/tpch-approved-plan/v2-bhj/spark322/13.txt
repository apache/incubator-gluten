== Physical Plan ==
AdaptiveSparkPlan (32)
+- == Final Plan ==
   VeloxColumnarToRowExec (19)
   +- ^ SortExecTransformer (17)
      +- ^ RegularHashAggregateExecTransformer (16)
         +- ^ RegularHashAggregateExecTransformer (15)
            +- ^ ProjectExecTransformer (14)
               +- ^ RegularHashAggregateExecTransformer (13)
                  +- ^ RegularHashAggregateExecTransformer (12)
                     +- ^ ProjectExecTransformer (11)
                        +- ^ GlutenBroadcastHashJoinExecTransformer LeftOuter (10)
                           :- ^ BatchScanExecTransformer (1)
                           +- ^ InputIteratorTransformer (9)
                              +- ^ InputAdapter (8)
                                 +- ^ BroadcastQueryStage (7)
                                    +- ColumnarBroadcastExchange (6)
                                       +- ^ ProjectExecTransformer (4)
                                          +- ^ FilterExecTransformer (3)
                                             +- ^ BatchScanExecTransformer (2)
+- == Initial Plan ==
   Sort (31)
   +- HashAggregate (30)
      +- HashAggregate (29)
         +- HashAggregate (28)
            +- HashAggregate (27)
               +- Project (26)
                  +- BroadcastHashJoin LeftOuter BuildRight (25)
                     :- BatchScan (20)
                     +- BroadcastExchange (24)
                        +- Project (23)
                           +- Filter (22)
                              +- BatchScan (21)


(1) BatchScanExecTransformer
Output [1]: [c_custkey#X]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
ReadSchema: struct<c_custkey:bigint>

(2) BatchScanExecTransformer
Output [3]: [o_orderkey#X, o_custkey#X, o_comment#X]
DataFilters: [NOT o_comment#X LIKE %special%requests%, isnotnull(o_comment#X), isnotnull(o_custkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(o_comment), IsNotNull(o_custkey)]
ReadSchema: struct<o_orderkey:bigint,o_custkey:bigint,o_comment:string>

(3) FilterExecTransformer
Input [3]: [o_orderkey#X, o_custkey#X, o_comment#X]
Arguments: ((NOT o_comment#X LIKE %special%requests% AND isnotnull(o_comment#X)) AND isnotnull(o_custkey#X))

(4) ProjectExecTransformer
Output [2]: [o_orderkey#X, o_custkey#X]
Input [3]: [o_orderkey#X, o_custkey#X, o_comment#X]

(5) WholeStageCodegenTransformer (X)
Input [2]: [o_orderkey#X, o_custkey#X]
Arguments: false

(6) ColumnarBroadcastExchange
Input [2]: [o_orderkey#X, o_custkey#X]
Arguments: HashedRelationBroadcastMode(List(input[1, bigint, true]),false), [plan_id=X]

(7) BroadcastQueryStage
Output [2]: [o_orderkey#X, o_custkey#X]
Arguments: 0

(8) InputAdapter
Input [2]: [o_orderkey#X, o_custkey#X]

(9) InputIteratorTransformer
Input [2]: [o_orderkey#X, o_custkey#X]

(10) GlutenBroadcastHashJoinExecTransformer
Left keys [1]: [c_custkey#X]
Right keys [1]: [o_custkey#X]
Join condition: None

(11) ProjectExecTransformer
Output [2]: [c_custkey#X, o_orderkey#X]
Input [3]: [c_custkey#X, o_orderkey#X, o_custkey#X]

(12) RegularHashAggregateExecTransformer
Input [2]: [c_custkey#X, o_orderkey#X]
Keys [1]: [c_custkey#X]
Functions [1]: [partial_count(o_orderkey#X)]
Aggregate Attributes [1]: [count#X]
Results [2]: [c_custkey#X, count#X]

(13) RegularHashAggregateExecTransformer
Input [2]: [c_custkey#X, count#X]
Keys [1]: [c_custkey#X]
Functions [1]: [count(o_orderkey#X)]
Aggregate Attributes [1]: [count(o_orderkey#X)#X]
Results [2]: [c_custkey#X, count(o_orderkey#X)#X]

(14) ProjectExecTransformer
Output [1]: [count(o_orderkey#X)#X AS c_count#X]
Input [2]: [c_custkey#X, count(o_orderkey#X)#X]

(15) RegularHashAggregateExecTransformer
Input [1]: [c_count#X]
Keys [1]: [c_count#X]
Functions [1]: [partial_count(1)]
Aggregate Attributes [1]: [count#X]
Results [2]: [c_count#X, count#X]

(16) RegularHashAggregateExecTransformer
Input [2]: [c_count#X, count#X]
Keys [1]: [c_count#X]
Functions [1]: [count(1)]
Aggregate Attributes [1]: [count(1)#X]
Results [2]: [c_count#X, count(1)#X AS custdist#X]

(17) SortExecTransformer
Input [2]: [c_count#X, custdist#X]
Arguments: [custdist#X DESC NULLS LAST, c_count#X DESC NULLS LAST], true, 0

(18) WholeStageCodegenTransformer (X)
Input [2]: [c_count#X, custdist#X]
Arguments: false

(19) VeloxColumnarToRowExec
Input [2]: [c_count#X, custdist#X]

(20) BatchScan
Output [1]: [c_custkey#X]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
ReadSchema: struct<c_custkey:bigint>

(21) BatchScan
Output [3]: [o_orderkey#X, o_custkey#X, o_comment#X]
DataFilters: [NOT o_comment#X LIKE %special%requests%, isnotnull(o_comment#X), isnotnull(o_custkey#X)]
Format: parquet
Location: InMemoryFileIndex(1 paths)[*]
PushedFilters: [IsNotNull(o_comment), IsNotNull(o_custkey)]
ReadSchema: struct<o_orderkey:bigint,o_custkey:bigint,o_comment:string>

(22) Filter
Input [3]: [o_orderkey#X, o_custkey#X, o_comment#X]
Condition : ((NOT o_comment#X LIKE %special%requests% AND isnotnull(o_comment#X)) AND isnotnull(o_custkey#X))

(23) Project
Output [2]: [o_orderkey#X, o_custkey#X]
Input [3]: [o_orderkey#X, o_custkey#X, o_comment#X]

(24) BroadcastExchange
Input [2]: [o_orderkey#X, o_custkey#X]
Arguments: HashedRelationBroadcastMode(List(input[1, bigint, true]),false), [plan_id=X]

(25) BroadcastHashJoin
Left keys [1]: [c_custkey#X]
Right keys [1]: [o_custkey#X]
Join condition: None

(26) Project
Output [2]: [c_custkey#X, o_orderkey#X]
Input [3]: [c_custkey#X, o_orderkey#X, o_custkey#X]

(27) HashAggregate
Input [2]: [c_custkey#X, o_orderkey#X]
Keys [1]: [c_custkey#X]
Functions [1]: [partial_count(o_orderkey#X)]
Aggregate Attributes [1]: [count#X]
Results [2]: [c_custkey#X, count#X]

(28) HashAggregate
Input [2]: [c_custkey#X, count#X]
Keys [1]: [c_custkey#X]
Functions [1]: [count(o_orderkey#X)]
Aggregate Attributes [1]: [count(o_orderkey#X)#X]
Results [1]: [count(o_orderkey#X)#X AS c_count#X]

(29) HashAggregate
Input [1]: [c_count#X]
Keys [1]: [c_count#X]
Functions [1]: [partial_count(1)]
Aggregate Attributes [1]: [count#X]
Results [2]: [c_count#X, count#X]

(30) HashAggregate
Input [2]: [c_count#X, count#X]
Keys [1]: [c_count#X]
Functions [1]: [count(1)]
Aggregate Attributes [1]: [count(1)#X]
Results [2]: [c_count#X, count(1)#X AS custdist#X]

(31) Sort
Input [2]: [c_count#X, custdist#X]
Arguments: [custdist#X DESC NULLS LAST, c_count#X DESC NULLS LAST], true, 0

(32) AdaptiveSparkPlan
Output [2]: [c_count#X, custdist#X]
Arguments: isFinalPlan=true